#BlueJ class context
comment0.params=n
comment0.target=ListaNombres(int)
comment0.text=\r\n\ Constructor\ de\ la\ clase\ ListaNombres\r\n
comment1.params=
comment1.target=boolean\ listaVacia()
comment1.text=\r\n\ @return\ \ true\ si\ la\ lista\ est\u00E1\ vac\u00EDa\ \ \ \r\n
comment10.params=
comment10.target=java.lang.String\ toString()
comment10.text=\r\n\ Representaci\u00F3n\ textual\ de\ la\ cadena\r\n\ \r\n\ @return\ la\ cadena\ resultante\ \ \ \ \r\n
comment11.params=
comment11.target=void\ cargarDeFichero()
comment11.text=\r\n\ Lee\ de\ un\ fichero\ de\ texto\ una\ serie\ \r\n\ de\ nombres\ con\ ayuda\ de\ un\ objeto\ de\ la\ \r\n\ clase\ Scanner\ y\ los\ almacena\ en\ la\ lista\r\n
comment2.params=
comment2.target=boolean\ listaLlena()
comment2.text=\r\n\ \r\n\ @return\ \ true\ si\ la\ lista\ est\u00E1\ llena\ \ \ \r\n
comment3.params=nombre
comment3.target=boolean\ insertarNombre(java.lang.String)
comment3.text=\r\n\ Inserta\ un\ nombre\ en\ la\ lista\ \u00FAnicamente\r\n\ si\ no\ est\u00E1\ y\ la\ lista\ no\ est\u00E1\ llena.\ La\ inserci\u00F3n\ se\ hace\ de\ tal\r\n\ manera\ que\ el\ nombre\ queda\ colocado\ en\ el\ \r\n\ lugar\ que\ le\ corresponde\ manteniendo\ el\ orden\ \r\n\ de\ la\ lista\ (no\ se\ utiliza\ ning\u00FAn\ algoritmo\ de\ ordenaci\u00F3n)\r\n\ Importan\ may\u00FAsculas\ y\ min\u00FAsculas\r\n\ \r\n\ @param\ nombre\ el\ nombre\ a\ insertar\r\n\ @return\ \ true\ si\ la\ inserci\u00F3n\ se\ hace\ con\ \u00E9xito\ \ \ \r\n\r\n
comment4.params=nombre
comment4.target=boolean\ estaNombre(java.lang.String)
comment4.text=\r\n\ \ Busca\ un\ nombre\ en\ la\ lista\r\n\ \ Puesto\ que\ la\ lista\ est\u00E1\ en\ todo\ momento\ ordenada\r\n\ \ se\ hace\ una\ b\u00FAsqueda\ binaria\r\n\ \ @param\ \ nombre\ el\ nombre\ a\ buscar\r\n\ \ @return\ \ \ true\ si\ ya\ existe\ el\ nombre\ en\ la\ lista\ \ \r\n\ \ \ \r\n
comment5.params=
comment5.target=java.lang.String\ nombreMasLargo()
comment5.text=\r\n\ \ Busca\ y\ devuelve\ el\ nombre\ de\ mayor\ longitud\r\n\ \ en\ la\ lista.\ Si\ hay\ varios\ devuelve\ el\r\n\ \ primero\ encontrado\r\n\ \ Si\ la\ lista\ est\u00E1\ vac\u00EDa\ devuelve\ null\r\n\ \ \r\n\ \ @return\ \ \ el\ nombre\ m\u00E1s\ largo\ \ \r\n\ \ \r\n
comment6.params=letra
comment6.target=void\ borrarLetra(char)
comment6.text=\r\n\ Borra\ de\ la\ lista\ los\ nombres\ que\ empiezan\ por\ \r\n\ una\ letra\ determinada\ (s\u00ED\ importan\ may\u00FAsculas\ y\ min\u00FAsculas)\r\n\ No\ es\ lo\ mismo\ borrarLetra('A')\ que\ borrarLetra('a')\r\n\r\n\ @param\ letra\ la\ letra\ por\ la\ que\ han\ de\ empezar\ los\ nombres\ \r\n\ \ \ \ \r\n
comment7.params=p
comment7.target=void\ borrarDePosicion(int)
comment7.text=\r\n\ Borra\ un\ nombre\ de\ la\ posici\u00F3n\ indicada\r\n\ \r\n\r\n\ @param\ \ p\ posici\u00F3n\ del\ nombre\ a\ borrar\r\n\ \ \r\n
comment8.params=inicio
comment8.target=int\ empiezanPor(java.lang.String)
comment8.text=\r\n\ Cuenta\ cu\u00E1ntos\ nombres\ empiezan\ por\ una\ determinada\ \r\n\ cadena\ sin\ importar\ si\ es\ may\u00FAscula\ o\ min\u00FAscula\r\n\r\n\ @param\ \ la\ cadena\ de\ comienzo\r\n\ @return\ \ la\ cantidad\ de\ nombres\ calculados\ \ \ \r\n
comment9.params=letra
comment9.target=java.lang.String[]\ empiezanPorLetra(char)
comment9.text=\ \r\n\ \r\n\ Devuelve\ un\ array\ con\ los\ \ nombres\ que\ empiezan\ por\ una\ determinada\ \r\n\ letra\ sin\ importar\ si\ es\ may\u00FAscula\ o\ min\u00FAscula\r\n\ \r\n\ @param\ \ la\ letra\ de\ comienzo\r\n\ @return\ \ la\ cantidad\ de\ nombres\ encontrados\r\n\ \ \ \ \ \ \ \ \ \ con\ esa\ letra\ \ \ \r\n
numComments=12
